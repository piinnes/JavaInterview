### 8种基本数据类型

Java中有8种基本数据类型分为三大类。

#### 字符型

**char**

- char类型是一个单一的 16 位 Unicode 字符
- 最小值是 \u0000（即为0）
- 最大值是 \uffff（即为65,535）
- char 数据类型可以储存任何字符
- 对应的包装类：Character

#### 布尔型

**boolean**

- boolean数据类型表示一位的信息
- 只有两个取值：true 和 false
- 这种类型只作为一种标志来记录 true/false 情况
- 对应的包装类：Boolean

#### 数值型

1. ##### 整型：

   **byte**

   - 8位、有符号的以二进制补码表示的整数
   - min :  -128（-2^7）
   - max:  127(2^7-1)
   - default: 0
   - 对应包装类：Byte

   **short**

   - 16位、有符号的以二进制补码表示的整数
   - min :  -32768（-2^15）
   - max:  32767（2^15 - 1）
   - default: 0
   - 对应包装类：Short

   **int**

   - 32位、有符号的以二进制补码表示的整数
   - min :  -2,147,483,648（-2^31）
   - max:  2,147,483,647（2^31 - 1）
   - default: 0
   - 对应包装类：Integer

   **long**

   - 64位、有符号的以二进制补码表示的整数
   - min :  -9,223,372,036,854,775,808（-2^63）
   - max:  9,223,372,036,854,775,807（2^63 -1）
   - default: 0
   - 对应的包装类：Long

2. ##### 浮点型：

   **float**

   - 单精度、32位、符合IEEE 754标准的浮点数
   - float 在储存大型浮点数组的时候可节省内存空间
   - 浮点数不能用来表示精确的值，如货币
   - default: 0.0f
   - 对应的包装类：Float

   **double**

   - 双精度、64位、符合IEEE 754标准的浮点数
   - 浮点数的默认类型为double类型
   - double类型同样不能表示精确的值，如货币
   - default: 0.0d
   - 对应的包装类：Double

*String不是基本数据类型，是引用类型。*

### **关系**

#### **自动类型转换**

自动类型转换，也称隐式类型转换，是指不需要书写代码，由系统自动完成的类型转换。由于实际开发中这样的类型转换很多，所以 Java 语言在设计时，没有为该操作设计语法，而是由 JVM自动完成。

转换规则：从存储范围小的类型到存储范围大的类型。

具体规则为：byte→short(char)→int→long→float→double

也就是说 byte 类型的变量可以自动转换为 short 类型，示例代码：

byte b=10;
short sh=b;

这里在给sh赋值时，JVM首先将b的值转换成short类型然后再赋值给sh。

当然，在类型转换的时候也可以跳跃，就是byte也可以自动转换为int类型的。

注意问题：在整数之间进行类型转换的时候数值不会发生变化，但是当将整数类型特别是比较大的整数类型转换成小数类型的时候，由于存储精度的不同，可能会存在数据精度的损失。

#### **强制类型转换**

强制类型转换，也称显式类型转换，是指必须书写代码才能完成的类型转换。该类类型转换很可能存在精度的损失，所以必须书写相应的代码，并且能够忍受该种损失时才进行该类型的转换。

转换规则:从存储范围大的类型到存储范围小的类型。

具体规则为：double→float→long→int→short(char)→byte

语法格式为：(转换到的类型)需要转换的值

double d=3.14;
int i=(int) d;

注意问题:强制类型转换通常都会存储精度的损失，所以使用时需要谨慎。

#### **运算**

同类型之间运算，只需注意考虑临界值的问题。 

非同类型之间，会用到上面的1、2 转换相同类型进行运算。

### **经典面试题**

1.  **short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 +=1;有什么错?**

   答：对于short s1=1;s1=s1+1来说，在s1+1运算时会自动提升表达式的类型为int，那么将int赋予给short类型的变量s1会出现类型转换错误。

    对于short s1=1;s1+=1来说 +=是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。

2. **char类型变量能不能储存一个中文的汉子，为什么？**

   char类型变量是用来储存Unicode编码的字符的，unicode字符集包含了汉字，所以char类型当然可以存储汉字的，还有一种特殊情况就是某个生僻字没有包含在unicode编码字符集中，那么就char类型就不能存储该生僻字。

3. **Integer和int的区别**

   int是java的8种内置的原始数据类型。Java为每个原始类型都提供了一个封装类，Integer就是int的封装类。

   int变量的默认值为0，Integer变量的默认值为null，这一点说明Integer可以区分出未赋值和值为0的区别，比如说一名学生没来参加考试，另一名学生参加考试全答错了，那么第一名考生的成绩应该是null，第二名考生的成绩应该是0分。关于这一点Integer应用很大的。Integer类内提供了一些关于整数操作的一些方法，例如上文用到的表示整数的最大值和最小值。

4. **switch语句能否作用在byte上，能否作用在long上，能否作用在string上？**

    byte的存储范围小于int，可以向int类型进行隐式转换，所以switch可以作用在byte上

    long的存储范围大于int，不能向int进行隐式转换，只能强制转换，所以switch不可以作用在long上

    string在1.7版本之前不可以，1.7版本之后switch就可以作用在string上了

5. **是否存在 x>x+1?为什么？**

   这就是临界值，当x=最大值 时； 再加1（根据二进制运算+1）就超过了它的临界值，刚好会是它最小值。 

   举个例子吧，byte 8位， -128 ~ 127  

   127 二进制： 0111 1111

   1 二进制 ：   0000 0001

   相加结果：   1000 0000

   byte 8位 **有符号**，  1000 0000 刚好 为 -128