### 8种基本数据类型

Java中有8种基本数据类型分为三大类。

#### 字符型

**char**

- char类型是一个单一的 16 位 Unicode 字符
- 最小值是 \u0000（即为0）
- 最大值是 \uffff（即为65,535）
- char 数据类型可以储存任何字符
- 对应的包装类：Character

#### 布尔型

**boolean**

- boolean数据类型表示一位的信息
- 只有两个取值：true 和 false
- 这种类型只作为一种标志来记录 true/false 情况
- 对应的包装类：Boolean

#### 数值型

1. ##### 整型：

   **byte**

   - 8位、有符号的以二进制补码表示的整数
   - min :  -128（-2^7）
   - max:  127(2^7-1)
   - default: 0
   - 对应包装类：Byte

   **short**

   - 16位、有符号的以二进制补码表示的整数
   - min :  -32768（-2^15）
   - max:  32767（2^15 - 1）
   - default: 0
   - 对应包装类：Short

   **int**

   - 32位、有符号的以二进制补码表示的整数
   - min :  -2,147,483,648（-2^31）
   - max:  2,147,483,647（2^31 - 1）
   - default: 0
   - 对应包装类：Integer

   **long**

   - 64位、有符号的以二进制补码表示的整数
   - min :  -9,223,372,036,854,775,808（-2^63）
   - max:  9,223,372,036,854,775,807（2^63 -1）
   - default: 0
   - 对应的包装类：Long

2. ##### 浮点型：

   **float**

   - 单精度、32位、符合IEEE 754标准的浮点数
   - float 在储存大型浮点数组的时候可节省内存空间
   - 浮点数不能用来表示精确的值，如货币
   - default: 0.0f
   - 对应的包装类：Float

   **double**

   - 双精度、64位、符合IEEE 754标准的浮点数
   - 浮点数的默认类型为double类型
   - double类型同样不能表示精确的值，如货币
   - default: 0.0d
   - 对应的包装类：Double

*String不是基本数据类型，是引用类型。*

### **关系**

#### **自动类型转换**

自动类型转换，也称隐式类型转换，是指不需要书写代码，由系统自动完成的类型转换。由于实际开发中这样的类型转换很多，所以 Java 语言在设计时，没有为该操作设计语法，而是由 JVM自动完成。

转换规则：从存储范围小的类型到存储范围大的类型。

具体规则为：byte→short(char)→int→long→float→double

也就是说 byte 类型的变量可以自动转换为 short 类型，示例代码：

byte b=10;
short sh=b;

这里在给sh赋值时，JVM首先将b的值转换成short类型然后再赋值给sh。

当然，在类型转换的时候也可以跳跃，就是byte也可以自动转换为int类型的。

注意问题：在整数之间进行类型转换的时候数值不会发生变化，但是当将整数类型特别是比较大的整数类型转换成小数类型的时候，由于存储精度的不同，可能会存在数据精度的损失。

#### **强制类型转换**

强制类型转换，也称显式类型转换，是指必须书写代码才能完成的类型转换。该类类型转换很可能存在精度的损失，所以必须书写相应的代码，并且能够忍受该种损失时才进行该类型的转换。

转换规则:从存储范围大的类型到存储范围小的类型。

具体规则为：double→float→long→int→short(char)→byte

语法格式为：(转换到的类型)需要转换的值

double d=3.14;
int i=(int) d;

注意问题:强制类型转换通常都会存储精度的损失，所以使用时需要谨慎。

#### **运算**

同类型之间运算，只需注意考虑临界值的问题。 

非同类型之间，会用到上面的1、2 转换相同类型进行运算。

### 自动装箱与拆箱

- **装箱**：将基本类型用它们对应的引用类型包装起来；

- **拆箱**：将包装类型转换为基本数据类型；

  举例：

  ```java
  Integer i = 10;  //装箱
  int n = i;   //拆箱
  ```

  装箱其实就是调用了 包装类的`valueOf()`方法，拆箱其实就是调用了 `xxxValue()`方法。

  因此，

  - `Integer i = 10` 等价于 `Integer i = Integer.valueOf(10)`
  - `int n = i` 等价于 `int n = i.intValue()`;

#### 8 种基本类型的包装类和常量池

Java 基本类型的包装类的大部分都实现了常量池技术。`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应

类型的缓存数据，`Character` 创建了数值在[0,127]范围的缓存数据，`Boolean` 直接返回 `True` Or `False`。

如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。

两种浮点数类型的包装类 `Float`,`Double` 并没有实现常量池技术。

```java
Integer i1 = 33;

Integer i2 = 33;

System.out.println(i1 == i2);// 输出 true
Integer i3 = 333;

Integer i4 = 333;

System.out.println(i3 == i4);// 输出 false

Float i11 = 333f;

Float i22 = 333f;

System.out.println(i11 == i22);// 输出 false

Double i5 = 1.2;

Double i6 = 1.2;

System.out.println(i5 == i6);// 输出 false
```

包装类型间的相等判断应该用equals，而不是'==' 

![img](https://camo.githubusercontent.com/1787ac3ea56e56450b185b8e6dccb0bfd4ce60cafe05ffdecf31f3e64c833724/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303432323136343534343834362e706e67)

### **经典面试题**

1.  **short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 +=1;有什么错?**

   答：对于short s1=1;s1=s1+1来说，在s1+1运算时会自动提升表达式的类型为int，那么将int赋予给short类型的变量s1会出现类型转换错误。

    对于short s1=1;s1+=1来说 +=是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。

2. **char类型变量能不能储存一个中文的汉字，为什么？**

   char类型变量是用来储存Unicode编码的字符的，unicode字符集包含了汉字，所以char类型当然可以存储汉字的，还有一种特殊情况就是某个生僻字没有包含在unicode编码字符集中，那么就char类型就不能存储该生僻字。

3. **Integer和int的区别**

   int是java的8种内置的原始数据类型。Java为每个原始类型都提供了一个封装类，Integer就是int的封装类。

   int变量的默认值为0，Integer变量的默认值为null，这一点说明Integer可以区分出未赋值和值为0的区别，比如说一名学生没来参加

   考试，另一名学生参加考试全答错了，那么第一名考生的成绩应该是null，第二名考生的成绩应该是0分。关于这一点Integer应用很

   大的。Integer类内提供了一些关于整数操作的一些方法，例如上文用到的表示整数的最大值和最小值。

4. **switch语句能否作用在byte上，能否作用在long上，能否作用在string上？**

    byte的存储范围小于int，可以向int类型进行隐式转换，所以switch可以作用在byte上

    long的存储范围大于int，不能向int进行隐式转换，只能强制转换，所以switch不可以作用在long上

    string在1.7版本之前不可以，1.7版本之后switch就可以作用在string上了

5. **是否存在 x>x+1?为什么？**

   这就是临界值，当x=最大值 时； 再加1（根据二进制运算+1）就超过了它的临界值，刚好会是它最小值。 

   举个例子吧，byte 8位， -128 ~ 127  

   127 二进制： 0111 1111

   1 二进制 ：   0000 0001

   相加结果：   1000 0000

   byte 8位 **有符号**，  1000 0000 刚好 为 -128